# OOP(Object Oriented Programming)
## 객체 지향 프로그래밍
<p align="center">
    <img width="350px" src="https://media.vlpt.us/post-images/cyranocoding/6c8e33a0-b22a-11e9-a4ce-730fc6b3757a/oop.png">
</p>

- 컴퓨터 프로그램을 **“객체(Object)"** 들의 모임으로 파악하고자 하는 프로그래밍의 패러다임
- 각 **“객체(Object)"** 들은 서로 메시지를 주고 받을 수 있으며 데이터를 처리할 수 있다.
 ## 객체 지향 프로그래밍의 장점
 **객체 지향 프로그래밍의 중요한 특성은 강한 응집력(Strong Cohesion)과 약한 결합력(Weak Coupling)을 지향한다는 점이다.**
- 프로그램을 **유연하고 변경이 용이하게** 만든다.
- 프로그램의 **개발과 보수를 간편하게** 만든다.
- **직관적인 코드 분석**을 가능하게 한다.
### 응집력(Cohesion)
: 프로그램의 한 요소가 해당 기능을 수행하기 위해 얼마만큼의 연관된 책임과 아이디어가 뭉쳐있는지를 나타내는 정도
- 프로그램의 한 요소가 특정 목적을 위해 밀접하게 연관된 기능들이 모여서 구현되어 있다.
- 지나치게 많은 일을 하지 않으면 그것을 응집력이 높다고 표현한다
### 결합력(coupling)
: 프로그램 코드의 한 요소가 다른 것과 얼마나 강력하게 연결되어 있는지, 얼마나 의존적인지를 나타내는 정도.
- 결합력이 낮다는 것은 한 요소가 다른 요소들과 관계를 크게 맺고 있지 않은 상태를 의미한다.

### OOP의 경우 클래스에 하나의 문제 해결을 위해 데이터를 모아 놓은 객체를 활용한 프로그래밍을 지향하므로 응집력을 강화하며, 클래스 간에 독립적으로 디자인함으로써 결합력을 약하게 할 수 있다.

## OOP의 기본 구성 요소
- **클래스(Class)**
    - 같은 종류의 집단에 속하는 속성과 행위를 정의한 것.
    - 다른 클래스와 독립적으로 디자인해야 한다. 
    - 필드, 매서드, 생성자로 이루어져있다.
- 객체(Object)
    - 클래스의 인스턴스(Instance)
    - 상위 클래스의 속성을 가지고 있다
    - 개별적인 특성과 행위(Method)를 가지고 있다.
- 메서드(Method)
    - 클래스로부터 생성된 객체를 사용하는 방법.
    - 객체의 속성을 조작하는 데 사용된다.
## OOP의 특성
### 캡슐화(Encapsulatoin)
> 캡슐화는 객체의 데이터를 외부에서 직접 접근하지 못하게 막고, 함수를 통해서만 조작이 가능하게 하는 작업이다.

- 변수나 Method를 하나로 묶는것
- 자신이 가지고 있는 속성에 대해서 해당 상태를 변경하는 기능을 제공해야 한다.
- 각각의 Method를 서로 연관성이 있어야한다.
- 객체의 데이터를 외부에서 직접 접근x
- 함수를 통해서만 조작 가능 (ex. getter, setter, 생성자 등...)
- ex) public, private, protected, default

### 추상화(Abstraction)
> 추상화는 객체들이 가진 공통의 특성들을 파악하고 불필요한 특성들을 제거하는 과정을 말한다.

- 객체들이 가진 공통의 특성들을 파학하고 불필요한 특성들을 제거하는 과정
- 객체들이 가진 동작들을 기준으로 이용자들이 동작만 쉽게 구동할 수 있도록한다.

### 일반화 관계(Generalization)
>일반화는 여러 개체들이 가진 공통된 특성을 부각시켜 하나의 개념이나 법칙으로 성립시키는 과정이다.

- 일반화 관계는 객체지향 프로그래밍 관점에서는 **상속 관계** 라고 한다.
- 따라서 속성이나 기능의 재사용만 강조해서 사용하는 경우가 많다.
- 하지만 이는 일반화 관계를 **극히 한정되게 바라보는 시각**이다.  

**일반화는 또 다른 캡슐화**  
일반화 관계는 자식 클래스를 외부로부터 은닉하는 캡슐화의 일종이다.
- EX)
    - <p align="center">
    <img width="600px" src="https://gmlwjd9405.github.io/images/oop-features/generalization.png">
    </p>

    - 사람’클래스 관점에서는 구체적인 자동차의 종류가 숨겨져 있다.
    - 즉, 대리 운전자가 자동차의 종류에 따라 운전에 영향을 받지는 않을 것이다.
    - 이와 같이 새로운 자동차를 운전해야 하는 경우에도 ‘사람’클래스는 영향을 받지 않는다.
- 일반화 관계는 한 클래스 안에 있는 속성 및 연산들의 캡슐화에 한정되지 않는다.
    - 즉, 외부 세계에 **자식 클래스 자체를 캡슐화(또는 은닉)하는 것** 으로 확장된다.
    - 서브 클래스의 캡슐화는 외부 클라이언트가 개별적인 클래스들과 무관하게 프로그래밍을 할 수 있게 한다.
### 다형성 (Polymorphism)
>다형성은 서로 다른 클래스의 객체가 **같은 메시지** 를 받았을 때, **각자의 방식** 으로 동작하는 능력이다
- 다형성이 상속과 연계되어 동작하면 매우 효과적이다
- 다형성과 일반화 관계는 코드를 간결하게 할 뿐 아니라 변화에도 유연하게 대처할 수 있게한다
- ex) @Overriding, Overloading
```java
// 부모 클래스
public abstract class Pet {
  public abstract void talk();
}

// 자식 클래스
public class Cat extends Pet {
  public void talk(){ System.out.println("야옹"); }
}
public class Dog extends Pet {
  public void talk(){ System.out.println("멍멍"); }
}
public class Parrot extends Pet {
  public void talk(){ System.out.println("안녕"); }
}
```

## SOLID
### SRP:단일 책임 원칙(Single Responsibility Principle)
>성된 클래스는 하나의 기능만 가지며, 클래스가 제공하는 모든 서비스는 그 **하나의 책임을 수행하는 데 집중되어 있어야 한다.**
- 변화에 대한 유연성 확보
- 낮은 결합도, 높은 응집도 추구
### OCP: 개발-폐쇄 원칙(Open Closed Principle)
>소프트웨어의 구성요소(컴포넌트, 클래스, 모듈, 함수)는 **확장에는 열려있고, 변경에는 닫혀있어야 한다.**
- 상위 클래스 또는 인터페이스를 중간에 둠으로써, 자신의 변화에 대해서 폐쇄적이지만,
  인터페이스는 외부의 변화에 대해서 확장을 개방해 줄 수 있다.
- 이러한 부분은 JDBC, Hibernate등 JAVA Stream(I,O) 에서 찾아볼 수 있다.
### LSP: 리스코프 치환 원칙(Liscov Substitution Principle)
>서브 타입은 언제나 기반 타입으로 **교체할 수 있어야 한다.**
- 즉 인터페이스만 알면 구현체를 몰라도 사용 가능해야한다.
- 다형성
### ISP: 인터페이스 분리 원칙(InterFace Segregation Principle)
>자신이 사용하지 않는 인터페이스는 **구현하지 말아야 한다.**
- 인터페이스를 다시 작게 나누어 만든다.
- 두 개 이상의 인터페이스가 필요한 경우 다중 인터페이스 상속으로 구현하는 것이 좋다.
### DIP: 의존성 역전 원칙(Dependency Inversion Principle)
>상위 모듈은 하위 모듈에 **의존해선 안된다.**
- 상위, 하위 모듈은 모두 추상화에 의존해야 한다.
- 세부사항이 추상화에 의존해야한다.